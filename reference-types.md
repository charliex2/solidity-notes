# å¼•ç”¨æ•°æ®ç±»åž‹

å¼•ç”¨æ•°æ®ç±»åž‹æ˜¯æŒ‡æœ‰å¤šä¸ªåç§°ï¼ˆå¼•ç”¨ï¼‰å¯ä»¥è®¿é—®å’Œä¿®æ”¹å®ƒçš„å€¼ã€‚ä¸Žå€¼ç±»åž‹ä¸åŒçš„æ˜¯ï¼Œå€¼ç±»åž‹æ¯æ¬¡éƒ½æ˜¯ä¸€ä¸ªç‹¬ç«‹çš„å‰¯æœ¬ã€‚å¼•ç”¨ç±»åž‹åŒ…æ‹¬ç»“æž„ã€æ•°ç»„å’Œæ˜ å°„ã€‚

## æ¦‚è¿°

### æ•°æ®ä½ç½®

**å¼•ç”¨ç±»åž‹å¿…é¡»æ˜Žç¡®æŒ‡æ˜Žæ•°æ®å­˜å‚¨æ‰€åœ¨çš„ä½ç½®**ï¼Œé™¤äº†åˆçº¦çš„æˆå‘˜å˜é‡ï¼ˆçŠ¶æ€å˜é‡ï¼Œstate variableï¼‰æ˜¯é»˜è®¤ `storage`ä½ç½®çš„ã€‚

> åœ¨ Solidity 0.5.0 ä¹‹å‰ï¼Œæ•°æ®ä½ç½®å¯ä»¥çœç•¥ï¼Œå› ä¸º EVM æ ¹æ®æ•°å€¼ç±»åž‹å’Œå‡½æ•°ç±»åž‹ç­‰è®¾å®šäº†é»˜è®¤æ•°æ®ä½ç½®ã€‚ä½†æ˜¯ä»Žè¯¥ç‰ˆæœ¬å¼€å§‹ï¼Œæ‰€æœ‰å¤æ‚ç±»åž‹éƒ½éœ€è¦æ˜¾å¼æŒ‡å®šæ•°æ®ä½ç½®ã€‚
>
> ðŸ¤” è¿™é‡Œçš„â€å¤æ‚ç±»åž‹â€œåº”è¯¥æŒ‡çš„å°±æ˜¯å¼•ç”¨ç±»åž‹ã€‚

- memory ï¼š æ•°æ®å­˜åœ¨å†…å­˜ä¸­ï¼Œå› æ­¤æ•°æ®ä»…åœ¨å…¶ç”Ÿå‘½å‘¨æœŸå†…ï¼ˆå‡½æ•°è°ƒç”¨æœŸé—´ï¼‰æœ‰æ•ˆï¼Œä¸èƒ½ç”¨äºŽå¤–éƒ¨è°ƒç”¨ï¼›

- storageï¼šåŒºå—é“¾ä¸­ï¼Œåªè¦åˆçº¦å­˜åœ¨åˆ™ä¸€ç›´å­˜å‚¨ï¼›

- calldataï¼šç”¨æ¥ä¿å­˜å‡½æ•°å‚æ•°çš„ç‰¹æ®Šæ•°æ®ä½ç½®ï¼Œè¯¥ä½ç½®ä¸ºåªè¯»ä¸èƒ½ä¿®æ”¹ã€éžæŒä¹…åŒ–çš„æ•°æ®ä½ï¼Œå…¶è¡Œä¸ºä¸Ž memoery ç±»ä¼¼ï¼›

  Solidity 0.6.9 ç‰ˆæœ¬ä¹‹å‰ calldata ä»…èƒ½ç”¨äºŽå¤–éƒ¨å‡½æ•°çš„å‚æ•°ï¼Œè¯¥ç‰ˆæœ¬åŽå¯ä»¥ç”¨äºŽä»»ä½•å‡½æ•°ã€‚

### å¼•ç”¨ä¸Žæ‹·è´

æ›´æ”¹æ•°æ®ä½ç½®çš„èµ‹å€¼ä¸Žç±»åž‹è£…æ¢æ€»ä¼šè‡ªåŠ¨ç”Ÿæˆä¸€ä»½æ‹·è´ã€‚ä¸€èˆ¬æƒ…å†µä¸‹ï¼ŒåŒä¸€æ•°æ®ä½çš„èµ‹å€¼æ˜¯ç”Ÿæˆä¸€ä¸ªå¼•ç”¨ï¼Œä½†å¯¹åº”`storage`æ•°æ®ä½ç½®çš„æ•°æ®åœ¨æŸäº›åœºæ™¯ä¸‹ä¹Ÿæ˜¯ç”Ÿæˆä¸€ä»½æ‹·è´ã€‚

ä¸‹é¢ç½—åˆ—å‡ æ¡è§„åˆ™ï¼š

- storage, memory, calldata ä¹‹é—´çš„èµ‹å€¼æ€»æ˜¯ç”Ÿæˆä¸€ä»½æ‹·è´ï¼›
- memory ä¹‹é—´çš„èµ‹å€¼æ˜¯å¼•ç”¨ï¼›
- å°† storage é‡Œçš„å˜é‡èµ‹å€¼ç»™å±€éƒ¨ storage å˜é‡ï¼Œä¹Ÿæ˜¯å¼•ç”¨ï¼›
- å…¶ä»–å‚¨å­˜ä½ç½®å‘ storage ä½ç½®çš„å˜é‡èµ‹å€¼ï¼Œæ€»æ˜¯ç”Ÿæˆä¸€ä»½æ‹·è´ã€‚ä¾‹å¦‚å‘çŠ¶æ€å˜é‡æˆ–è€…storageä½ç½®çš„ Struct å±€éƒ¨å˜é‡ï¼ˆå³æ—¶è¿™ä¸ªå±€éƒ¨å˜é‡åªæ˜¯ä¸ªå¼•ç”¨ï¼‰èµ‹å€¼ã€‚

```js
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.5.0 <0.9.0;

contract C {
    // x çš„æ•°æ®ä½ç½®æ˜¯ storageã€‚è¿™æ˜¯ä»…æœ‰çš„æ•°æ®ä½ç½®å¯ä»¥çœç•¥çš„åœ°æ–¹ã€‚
    uint[] x;

    //  memoryArray çš„æ•°æ®ä½ç½®æ˜¯ memory.
    function f(uint[] memory memoryArray) public {
        x = memoryArray; // å¯è¡Œï¼Œæ•´ä¸ªæ•°ç»„è¢«æ‹·è´è¿›äº† storage
        uint[] storage y = x; // åˆ†é…äº†ä¸€ä¸ªæŒ‡é’ˆï¼ˆä¹Ÿå°±æ˜¯å¼•ç”¨ï¼‰
        y[7]; // fine, returns the 8th element
        y.pop(); // fine, modifies x through y
        delete x; // æ¸…æ¥šäº† xï¼Œ åŒæ—¶ä¹Ÿå½±å“åˆ°äº† y
        // The following does not work; it would need to create a new temporary /
        // unnamed array in storage, but storage is "statically" allocated:
      	// ðŸ¤” ç¿»è¯‘æ²¡çœ‹æ‡‚ï¼Œåº”è¯¥æ˜¯ y æŒ‡å‘çš„ storage æ•°æ®å·²ç»è¢«åˆ é™¤ï¼Œy æ²¡æœ‰æŒ‡å‘ä»»ä½•å­˜å‚¨ç©ºé—´äº†ï¼Œå› æ­¤å†ç»™ y èµ‹å€¼ä¼šå‡ºé”™ã€‚
        // y = memoryArray;
        // delete ä¼šé‡ç½®æŒ‡é’ˆï¼Œä½†æ­¤æ—¶ y å·²ç»æ²¡æœ‰å¼•ç”¨äº†ï¼Œå› æ­¤å¤±è´¥ã€‚
        // delete y;
        g(x); // calls g, handing over a reference to x
        h(x); // calls h and creates an independent, temporary copy in memory
    }

    function g(uint[] storage) internal pure {}
    function h(uint[] memory) public pure {}
}
```

## ç±»åž‹

1. [æ•°ç»„ array](variables/array.md)
2. [ç»“æž„ä½“ struct](variables/struct.md)
3. [æ˜ å°„ mapping](varibales/mapping.md)
